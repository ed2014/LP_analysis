---
title: "Analysis of L&P dataset"
output:
  html_document: default
  word_document: default
---


```{r LoadLibs, echo=FALSE, include=FALSE}
library(xtable)
library(knitr)
library(RSQLite)
library(lubridate)
library(stringr)
library(tidyr)
library(dplyr)
library(ggplot2)
library (hydroGOF)
library(scales)
library(GGally)

options("scipen"=100, "digits"=4) # prints not in scientific notation

```


## FIXME list

- Print numeric value of Surfacekl in csv output
- Use numeric value of parameters as characters througout to simplify comparisons
- Depth can come as numeric too
- The current criteria for parameter selection has HUGE leverage on results
- How to define best fit?????

## Load and massage the data

- Tidy up factors/levels (note the need to set new label on csv dataset)

- Separete in Sedling and regrowth phases

- Get data formats right


```{r LoadTidyUp, echo=FALSE,include=FALSE, echo=FALSE}

#dataRaw <- read.csv("C:\\GitHubRepos\\LP_analysis\\ObsPre.csv", header = TRUE, skip = 4)
dataRaw <- read.csv("K:\\CPDiary\\Data\\Lucerne & pasture drought trial 2011-2012\\ModelFitting\\ObsPre.csv", 
                    header = TRUE)
head(dataRaw)
summary(dataRaw)

# Create working df and sort out formats - 
dataWork <- as.data.frame(dataRaw)

# Force parameter values to factors
dataWork$Date <- as.Date(ymd(dataWork$Date))
dataWork$SurfaceKl <- as.factor(dataWork$SurfaceKl)
dataWork$RootFrontVelocity <- as.factor(dataWork$RootFrontVelocity)
dataWork$KLReduction <- as.factor(dataWork$KLReduction)

# sort depth out
dataWork$Depth <- gsub("D", "", dataWork$Depth)
dataWork$Depth <- factor(dataWork$Depth, 
                         levels = c(7, 23, 30, 50, 70, 90, 110, 130, 150))
dataWork$Depth <- as.factor(dataWork$Depth)

# Create separate Establishment and Regrowth periods
estDate <- "2012-06-01" # FIXME: find a more functional criteria later
#estDate <- "2012-01-01" # FIXME: test sensitivity to this date
#estDate <- "2012-06-01 00:00:00"
dataWork$Stage <- as.factor(ifelse(dataWork$Date<=estDate,"Est","Reg"))



# Check levels
levels(dataWork$Depth)
levels(dataWork$SurfaceKl)
levels(dataWork$KLReduction)
levels(dataWork$RootFrontVelocity)

# Check
head(dataWork)
summary(dataWork)
str(dataWork)


# create indexes to call later
dataWork$index <- paste0(dataWork$Crop, "_",
                         dataWork$Stage, "_SK:",
                              dataWork$SurfaceKl, "_KR:",
                              dataWork$KLReduction, "_RF:",
                              dataWork$RootFrontVelocity)

dataWork$index <- as.factor(dataWork$index)

# pooled by crop (excludes stage)
dataWork$index_crop <- paste0(dataWork$Crop, "_SK",
                              dataWork$SurfaceKl, "_KR:",
                              dataWork$KLReduction, "_RF:",
                              dataWork$RootFrontVelocity)

dataWork$index_crop <- as.factor(dataWork$index_crop)

# re-order fators (ensure Obs is the LAST one)
dataWork <- dataWork[c("Crop", "Irrigation",            
                       "Depth",
                       "Stage",
                       "Date",
                       "SurfaceKl", 
                       "KLReduction", 
                       "RootFrontVelocity", 
                       "index",
                       "index_crop",
                       "Pred", "Obs")]

```


## Check clean dataset


```{r, echo=FALSE}
# final product
str(dataWork)

```

```{r}
head(dataWork, 20)
```

```{r}
summary(dataWork)
```


## Compare Obs and simulated time-series 

- For "dryland"" crops just to check
- All simulated values (grey) and observed values (red)

```{r GraphExample, fig.height=18,fig.width=12, echo=FALSE}

# example of dryland crops
dataWork %>%
  filter(Irrigation =="None") %>%
  ggplot() +
  geom_point(aes(x=Date, y=Pred),colour="grey") +
  geom_point(aes(x=Date, y=Obs), size=2, colour="darkred") +
  facet_grid(Depth~Crop) +
  geom_vline(xintercept = as.numeric(as.Date(ymd(estDate))), linetype=2) 

```

## XY graph for Prediced x Obs for whole dataset now

```{r XYgraph , fig.height=18,fig.width=12, echo=FALSE}
dataWork %>%
  ggplot(aes(x=Pred, y=Obs,colour=factor(Depth))) +
  stat_smooth(method = "lm", se = TRUE, 
              linetype = 3,
              aes(colour=factor(Depth))) +
  geom_point() +
  facet_grid(Crop~Stage, scales ="free") +
  geom_abline(intercept = 0, slope = 1) 

```

## Create gauch stats function

```{r CreateStats, echo=FALSE, include=FALSE}

# Create stats function as per Gauch et al paper

gauchStats <- function(sim, meas) {

  n_s <- length(sim)
  n_m <- length(meas)
  model <- lm(meas~sim)
  sim_sq <- sum((sim - mean(sim))^2)
  mes_sq <- sum((meas - mean(meas))^2)
  r2 <- summary(model)$r.squared
  slope <- model$coefficients[[2]]

  sb <- (sum(mean(meas)) - sum(mean(sim)))^2
  nu <- (1-slope)^2 * (sim_sq/n_s)
  lc <- (1-r2) * (mes_sq/n_m)
  msd <- sb+nu+lc

  sb_r <- round((sb/msd)*100,1)
  nu_r <- round((nu/msd)*100,1)
  lc_r <- round((lc/msd)*100,1)

  msd_r <- sb_r+nu_r+lc_r

  # select which variables to output
  out <- c(sb_r, # output 1
           nu_r,
           lc_r, 
           msd_r, 
           round(r2*100,1)) # output 5

  return(out)

}

# test dataset
s <- c(4231.972,3935.604,3779.652,3627.687,3363.499,3230.566,2868.114,2868.827)
m <- c(4987.66,5636.09,4754.06,4114.53,4141.72,3704.06,5142.19,4762.03)

gauchStats(s,m)

```


## Creates a generic set of stats to output that includes gauch

```{r}

# Create a tailored common dplyr thread that do the stats for the df you have
doStats <-  function (x) {
    library(dplyr)
    x %>% dplyr::summarise(
    n = n(),
    r2 = gauchStats(Pred,Obs)[5],
    rmse = rmse(Pred,Obs),
    r_rmse = rmse(Pred,Obs)/mean(Obs)*100, # big precision to enable cretrial of selection
    nse = NSE(Pred,Obs),
    sb = gauchStats(Pred,Obs)[1],
    nu = gauchStats(Pred,Obs)[2],
    lc = gauchStats(Pred,Obs)[3]) 
}



# statsFunc <- function (sim, meas){
#     n = n()
#     r2 = gauchStats(sim,meas)[5]
#     rmse = rmse(sim,meas)
#     r_rmse = rmse(sim,Obs)/mean(meas)*100 # big precision to enable cretrial of selection 
#     nse = NSE(sim,meas)
#     sb = gauchStats(sim,meas)[1]
#     nu = gauchStats(sim,meas)[2]
#     lc = gauchStats(sim,meas)[3]
#     
#     out <- c(n, r2, rmse, r_rmse, nse, sb, nu, lc)
#     
#     return(out)
# } 
```

```{r}
# dataWork %>%
#   group_by(Crop, SurfaceKl, KLReduction, RootFrontVelocity, index, index_crop) %>%
#   summarise(
#     n = n(),
#     r2 = gauchStats(Pred,Obs)[5],
#     rmse = gauchStats(Pred,Obs)[3],
#     r_rmse = gauchStats(Pred,Obs)[4]*100, # big precision to enable cretrial of selection 
#     nse = gauchStats(Pred,Obs)[5],
#     sb = gauchStats(Pred,Obs)[6],
#     nu = gauchStats(Pred,Obs)[7],
#     lc = gauchStats(Pred,Obs)[8]) 

dataWork  %>%
group_by(Crop, SurfaceKl, KLReduction, RootFrontVelocity, index, index_crop) %>%
doStats()

```

## Calculate table of statistics


```{r DoStatsAll, echo=FALSE, include=TRUE}

# Pooled by Crop only - agregate and do stats across crops only
statDF_cropOnly <- dataWork %>%
  group_by(Crop, SurfaceKl, KLReduction, RootFrontVelocity, index_crop) %>%
  doStats()

#summary(statDF_cropOnly)

statDF_cropOnly


# Stats per layer
# Test version - not used
# TODO: Do stats by soil depth and drop similations that have poor fit on top layers OR ...



```

```{r}

# Pooled by Crop & Stage - Agregate all layers (i.e. remove Depth from grouping) and do stats for Crop and Stage
statDF_cropStage <- dataWork %>%
  dplyr::group_by(Crop, Stage, SurfaceKl, KLReduction, RootFrontVelocity, index) %>%
  doStats()

statDF_cropStage
  
```

```{r}
summary(statDF_cropStage)
```

```{r, fig.height=12,fig.width=12, echo=FALSE}

statDF_cropStageDepth <- dataWork %>%
  dplyr::group_by(Crop, Stage, Depth, SurfaceKl, KLReduction, RootFrontVelocity, index) %>%
  doStats()
  
summary(statDF_cropStageDepth)

# weights per layer
#weightsPerLayer <- c(2,1,1,1,1,1,1,1,1)

# STOPPED here need to change values of statDF_cropOnly and statDF_cropStage that where inverted
# Also need to get caegories numbers sorted
```

## Compare stats

- Many stats criteria are "highly" correlated (e.g. nse and r_rmse x rmse)
- Makes sense to combine criteria with low correclation
- Chosen r_rmse and LC at the moment

```{r AnalyseStats, fig.height=18,fig.width=12, echo=FALSE}

# relationship between stats
plot(statDF_cropOnly[,7:13], col=statDF_cropOnly$Crop)
legend(7,4.3,unique(statDF_cropOnly$Crop),col=1:length(statDF_cropOnly$Crop),pch=1)
#ggpairs(statDF_cropOnly[,7:13])
#ggpairs(statDF_cropOnly[,7:13]) # crashes with statDF_cropStage - too heavy

```

```{r, fig.height=18,fig.width=12, echo=FALSE}

# create categories of r_rmse

# statDF_cropStage$stats_cat<-cut(statDF_cropStage$r_rmse, seq(min(statDF_cropStage$r_rmse)*0.9,
#                                                     max(statDF_cropStage$r_rmse)*1.1,
#                                                     5, right=TRUE))

statDF_cropStage$stats_cat<-cut(statDF_cropStage$r_rmse, breaks = 100)



lv <- length(unique(statDF_cropStage$stats_cat))

colors <- colorRampPalette(c("blue", "green", "yellow", "red"))(lv)
# colors <- colorRampPalette(c("green", "yellow","red"))(lv)

statDF_cropStage$stats_cat <- factor(statDF_cropStage$stats_cat)

N <- nlevels(statDF_cropStage$stats_cat)

# Map rmsd
statDF_cropStage  %>% 
 # filter(Crop == "Lucerne") %>%
  ungroup() %>% # to allow mutate
  # mutate(
  #   SurfaceKl = as.factor(SurfaceKl),
  #   KLReduction = as.factor(KLReduction),
  #   RootFrontVelocity = as.factor(RootFrontVelocity)
  # ) %>%
  group_by(Crop, Stage) %>%
  ggplot(aes(x = SurfaceKl, 
             y = KLReduction, 
             z = RootFrontVelocity, 
             fill = stats_cat)) +
  geom_tile() + 
  coord_equal() +
  stat_contour() + 
  facet_grid(Stage~Crop+RootFrontVelocity) + 
#  scale_colour_gradientn(colours=terrain.colors(10)) + # FIXME: not working as wanted
  scale_fill_manual(values=colors, breaks=levels(statDF_cropStage$stats_cat)[seq(1, N, by=1)])+
  xlab("Surface kl category") +
  ylab("Exponential kl reduction category")+
  theme(text = element_text(size=16)) # + theme(axis.text.x = element_text(angle = 90, hjust = -0.5))

# add continuous value sof factor (parameters)
# statDF_cropOnly <- merge(statDF_cropOnly,kl_red_cats,by="KLReduction_cat")
# statDF_cropStage <- merge(statDF_cropOnly,kl_surface_cats,by="SurfaceKl")
# statDF_cropStage <- merge(statDF_cropOnly,RFV_cats,by="RootFrontVelocity")
```

```{r, fig.height=18,fig.width=12, echo=FALSE}
# Sensitivity plots for lc and rmse
statDF_cropStage %>%
  ungroup() %>% # to allow mutate
  # mutate(RootFrontVelocity = 
  #          factor(RootFrontVelocity,levels = c("Low", "Mid", "High"))) %>%
  ggplot(aes(x=r_rmse, colour=factor(SurfaceKl),fill=factor(SurfaceKl))) +
  geom_density(alpha=0.2) + 
  facet_grid(Stage~Crop)
```

```{r}
head(statDF_cropStage)
```

# Calculates the best fit (lowest r_rmse)


## For the "establishment phase only"

- Searches for best fit combination in establishment phase
- Selects root front velocity for that phase

```{r BestFitFinder1, echo=FALSE}

# Define a selection criteria

# NOT tested:
  # mutate(mse = rmse^2, nlc = 100-lc, mse_nlc = mse*nlc ) %>% # creates metrics for selecting best fit
  # filter(mse_nlc == min (mse_nlc)) %>%
  # filter(r_rmse == min(r_rmse) ) %>%
  # dplyr::select(-mse, -nlc, -mse_nlc)




# Finds selected qualtile threshold of RMSE (i.e. lowest X% of RMSE values) - not used yet
 p <- 0.25

 Q_luc_est <- statDF_cropStage %>% subset(Crop == "Lucerne" & Stage == "Est") %>% mutate(Q = quantile(rmse,probs=p))
 Q_luc_reg <- statDF_cropStage %>% subset(Crop == "Lucerne" & Stage == "Reg") %>% mutate(Q = quantile(rmse,probs=p))  
 Q_pas_est <- statDF_cropStage %>% subset(Crop == "Pasture" & Stage == "Est") %>% mutate(Q = quantile(rmse,probs=p)) 
 Q_pas_reg <- statDF_cropStage %>% subset(Crop == "Pasture" & Stage == "Reg") %>% mutate(Q = quantile(rmse,probs=p))  

 # FIXME: does not calculate quartile per group
 # statDF_cropStage %>% group_by(Crop,Stage) %>% mutate(Q = quantile(rmse,probs=p)) %>% summary() 

#Find good fit 25% population quartiles for each crop/stage FIXME: Sure there's a way to do this in groups (not used)
statDF_cropStage <- statDF_cropStage %>% mutate(rmseCut = ifelse(grepl("Lucerne_Est", index), Q_luc_est$Q[1],
                                ifelse(grepl("Lucerne_Reg", index), Q_luc_reg$Q[1],
                                    ifelse(grepl("Pasture_Est", index), Q_pas_est$Q[1],
                                       ifelse (grepl("Pasture_Reg", index), Q_pas_reg$Q[1], NA)))
                                ))
summary(statDF_cropStage)






```

```{r, fig.height=12,fig.width=12, echo=FALSE, warning=FALSE}
# finds lowest r_rmse for the establishment phase first
bestFit_Estab <- statDF_cropStage  %>%
  filter(Stage == "Est") %>%
  group_by(Crop) %>%
  filter(rmse<=rmseCut) %>% # was selecting good fit population
#  filter(r_rmse == min(r_rmse)) %>%
  filter(lc == max(lc)) %>%
  filter(r_rmse == min(r_rmse) )

rownames(bestFit_Estab) <- paste0(bestFit_Estab$Crop)

t(bestFit_Estab) %>%
  kable(format = "markdown")

selecParamsEst <- as.character(unique(bestFit_Estab$index))
RVF_luc_est <- bestFit_Estab[bestFit_Estab$Crop=="Lucerne",]$RootFrontVelocity
RVF_rye_est <- bestFit_Estab[bestFit_Estab$Crop=="Pasture",]$RootFrontVelocity
```

```{r, fig.height=12,fig.width=12, echo=FALSE, warning=FALSE}
# now select best fit for regrowth by setting the RFV to the selected in the establishment phase
bestFit_Reg <- statDF_cropStage  %>% 
  filter(  
    index == selecParamsEst[1] | # bring back only selected establishmnet combinations 
    index == selecParamsEst[2] |
    (Crop == "Lucerne" &  Stage == "Reg" & RootFrontVelocity == RVF_luc_est) |   
    (Crop == "Pasture" &  Stage == "Reg" & RootFrontVelocity == RVF_rye_est)) %>% 
  group_by(Crop, Stage) %>%
  filter(rmse<=rmseCut) %>%
 # filter(r_rmse == min(r_rmse)) %>%
  filter(lc == max(lc)) %>%
  filter(r_rmse == min(r_rmse) )
  
rownames(bestFit_Reg) <- paste0(bestFit_Reg$Crop,".",bestFit_Reg$Stage)

t(bestFit_Reg) %>%
  kable(format = "markdown")
```

## Best fit graphs for LUCERNE

```{r PlotBestFitsLuc, fig.height=18,fig.width=12, echo=FALSE}



# Input best fits here (FIXME: Automate this as a function from paramater estimation)

selecParams <- as.character(unique(bestFit_Reg$index))

sel1 <- dataWork %>%
  filter(
    # establisment
    index == selecParams[1] | # watch for this conventions of names (FIXME)
    # regrowth phase
    index == selecParams[2]
  ) 

# finds the closest point to the date of establihment
estLoc <- which.min(abs(as.Date(sel1$Date) - as.Date(estDate)))

# graph lucerne
sel1 %>%
  ggplot() +
  geom_point(aes(x=Date, y=Obs), size=2, shape = 1) +
  geom_line(aes(x=Date, y=Pred),colour="black") +
  facet_grid(Depth~Irrigation, scales = "free") + 
  scale_x_date(labels = date_format("%b")) + scale_shape(solid = FALSE) + 
  geom_vline(xintercept = as.numeric(sel1$Date[estLoc]),linetype = 2) +
  ylab("Volumetric soil moisture (mm)") +
  theme(text = element_text(size=16))

#sel1  %>%
#  ggplot(aes(x=Pred, y=Obs,fill = factor(Stage),colour=factor(Stage))) +
#  stat_smooth(method = "lm", se = TRUE, 
#            linetype = 3) +
#  geom_point() +
#  facet_grid(Depth~Irrigation, scales = "free") +
#  geom_abline(intercept = 0, slope = 1) 



```

```{r, fig.height=18,fig.width=12, echo=FALSE}
sel1  %>%
  ggplot(aes(x=Pred, y=Obs,fill = factor(Depth),colour=factor(Depth))) +
  stat_smooth(method = "lm", se = TRUE, 
            linetype = 3) +
  geom_point() +
  facet_grid(Stage~Irrigation, scales = "free") +
  geom_abline(intercept = 0, slope = 1) 
```

## Best fit graphs for RYEGRASS

```{r BestFitRye, fig.height=18,fig.width=12, echo=FALSE}


# Ryegrass
sel2 <- dataWork %>%
  filter(
    # establisment
    index == selecParams[3] |
    # regrowth phase
    index == selecParams[4]
  ) 


# graph ryegrass
 sel2 %>%
  ggplot() +
  geom_point(aes(x=Date, y=Obs), size=2, shape = 1) +
  geom_line(aes(x=Date, y=Pred),colour="black") +
  facet_grid(Depth~Irrigation, scales = "free") + 
  scale_x_date(labels = date_format("%b")) + scale_shape(solid = FALSE) + 
  geom_vline(xintercept = as.numeric(sel1$Date[estLoc]),linetype = 2)+
  ylab("Volumetric soil moisture (mm)") +
  theme(text = element_text(size=16))

#sel2  %>%
#  ggplot(aes(x=Pred, y=Obs,fill = factor(Stage),colour=factor(Stage))) +
#  stat_smooth(method = "lm", se = TRUE, 
#            linetype = 3) +
#  geom_point() +
#  facet_grid(Depth~Irrigation, scales = "free") +
#  geom_abline(intercept = 0, slope = 1) 

               



```

```{r, fig.height=12,fig.width=12, echo=FALSE}
sel2  %>%
  ggplot(aes(x=Pred, y=Obs,fill = factor(Depth),colour=factor(Depth))) +
  stat_smooth(method = "lm", se = TRUE, 
            linetype = 3) +
  geom_point() +
  facet_grid(Stage~Irrigation, scales = "free") +
  geom_abline(intercept = 0, slope = 1)   
```

## How does the best fit(s) look for RMSE by depth?

```{r RmsdPerDepth, echo = FALSE, fig.height=12,fig.width=12, echo=FALSE}

# calculate the stats for the BEST fit
# For each layer and depth combination to show trends
# IDEA: how much this afected water uptake?

sel3 <- rbind(sel1, sel2)

# calculates stats by depth
g1 <- sel3 %>%
  dplyr::group_by(Crop, Stage, Irrigation, Depth, Depth, SurfaceKl, KLReduction, RootFrontVelocity) %>%
  dplyr::summarise(
    n = n(),
    r2 = gauchStats(Pred,Obs)[5],
    rmse = round(rmse(Pred,Obs),3),
    r_rmse = round(rmse(Pred,Obs)/mean(Obs)*100,3),
    nse = round(NSE(Pred,Obs),1),
    sb = gauchStats(Pred,Obs)[1],
  nu = gauchStats(Pred,Obs)[2],
  lc = gauchStats(Pred,Obs)[3]) 

head(g1,20)



```

```{r, fig.height=12,fig.width=12, echo=FALSE}
# create a factor of  depth as integer
#g1$Depth <- as.numeric(gsub("D", "",g1$Depth)) # FIXME: move this to a higher level (earlier) as it can be used in other graphs

# _rmse by depth and crop
g1 %>%
  ggplot(aes(x=as.numeric(as.character(Depth))*-1, y=r_rmse, colour=factor(Stage))) +
  geom_point() +
  geom_line() +
 # geom_bar(aes(stats='identity')) +
  facet_grid(Crop~Irrigation) +
  coord_flip() + 
  geom_hline(yintercept = 20,linetype = 20) +
  labs(x = "Soil depth (cm)", y = "Relative Root Mean Squared Error (RMSE, % mean)") +
  theme(text = element_text(size=rel(4))) +
  theme(legend.text=element_text(size=16))
```


## RMSE components per depth

- Compare stats across depths now

- Partition of RMSE into Gauch fractions

- Standard bias (SB)

- Non Unit (NU)

- Lack of Correlation (LU)

```{r GauchStatsByDepth, echo = TRUE, fig.height=12,fig.width=12, echo=FALSE, warning=FALSE}

df <- g1 %>%
  mutate(mse = rmse^2, sb=sb*mse, nu=nu*mse, lc=lc*mse) %>%
 # dplyr::select(-n, -r2,-rmse,-r_rmse,-nse) %>%
  dplyr::select(-n, -r2,-r_rmse,-nse, -rmse) %>%
  tidyr::gather("StatsType","StatsValue", 8:10) %>%
  mutate(StatsType = factor(StatsType, levels = c("sb","nu","lc", "mse")))

# graph
  df %>%
#  filter(Crop == "Lucerne") %>%
  ungroup() %>%  
  mutate(Depth = factor(Depth, level = rev(Depth))) %>%
  ggplot(aes(x=Depth, y=StatsValue,fill=rev(StatsType))) +
  geom_bar(stat='identity') +
  facet_grid(Irrigation~Crop+Stage,scales = "free") +
  coord_flip() + 
  labs(x = "Soil depth (cm)", y = "MSE") +
  theme(text = element_text(size=rel(4))) +
  theme(legend.text=element_text(size=16))

```

```{r PinPointBestFit, echo = FALSE, fig.height=12,fig.width=12, echo=FALSE}
# 
# dfTemp <- statDF_cropStage %>%
#   group_by(Crop, Stage) %>%
#   dplyr::select(lc, r_rmse) %>%
#   summarise_each(funs(max, min)) %>%
#   dplyr::select(Crop, Stage, lc_max,r_rmse_min)

data_bf <- statDF_cropStage %>%
  mutate(BestFit = ifelse(index %in% bestFit_Reg$index,"Best", "NotBest")) %>%
  mutate(BestFit = factor(BestFit, levels=c("NotBest", "Best")))

bound_bf <- data_bf %>%
  filter(BestFit == "Best") %>%
  group_by(Crop, Stage) %>%
  dplyr::select(lc, r_rmse)


data_bf %>%
  ggplot(aes(x=lc, y=r_rmse)) +
  geom_point(aes(size=factor(SurfaceKl),
                 colour=factor(KLReduction),
                 shape=factor(RootFrontVelocity))) +
  scale_shape_manual(values=c(21,22,24))  +
  facet_grid(Stage~Crop, scales= "free") +
  xlab("Lack of correlation (LC, %MSE) ") +
  ylab(" Relative RMSE (% mean)") +
  geom_hline(data=bound_bf, aes(yintercept=r_rmse), linetype=2) +
  geom_vline(data=bound_bf, aes(xintercept=lc), linetype=2)
  
  
  # geom_hline(data=dfTemp, aes(yintercept=r_rmse_min), linetype=2) +
  # geom_vline(data=dfTemp, aes(xintercept=lc_max), linetype=2)


```

